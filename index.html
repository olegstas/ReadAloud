<!DOCTYPE html>
<html>
<head>
    <title>Text Reader</title>
    <style>
        /* CSS: –í–∏–ø—Ä–∞–≤–ª–µ–Ω–Ω—è –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è */
        .highlight { 
            background-color: #fff200; 
            color: #000;
            display: inline; /* –ì–∞—Ä–∞–Ω—Ç—É—î, —â–æ —Ü–µ –Ω–µ –±–ª–æ–∫–æ–≤–∏–π –µ–ª–µ–º–µ–Ω—Ç */
        }
        
        select { max-width: 200px; }
        
        #text {
            width: 100%;
            height: calc(100vh - 220px);
            border: 1px solid #ccc;
            padding: 10px;
            box-sizing: border-box;
            overflow: auto;
            white-space: pre-wrap; /* –ö—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è */
            font-family: monospace;
            line-height: 1.6; 
            margin-top: 10px;
            font-size: 20px;
            cursor: text;
            /* –í–∏–º–∏–∫–∞—î–º–æ –∑–∞–π–≤—ñ –≤—ñ–¥—Å—Ç—É–ø–∏ */
            overflow-wrap: break-word;
        }

        body { margin: 0; padding: 10px; box-sizing: border-box; font-family: sans-serif; }
        
        .controls-row { display: flex; flex-wrap: wrap; gap: 15px; align-items: center; margin-bottom: 10px; background: #f9f9f9; padding: 5px; border-radius: 5px; }
        .group { display: flex; align-items: center; gap: 5px; border-right: 1px solid #ddd; padding-right: 10px; }
        .group:last-child { border-right: none; }
        
        label { font-size: 0.9em; font-weight: bold; }
        button { padding: 5px 15px; cursor: pointer; font-weight: bold; }

        input[type="file"] { display: none; }
        .file-upload-btn {
            border: 1px solid #ccc; display: inline-block; padding: 4px 8px;
            cursor: pointer; background: #fff; border-radius: 3px; font-size: 0.9em; font-weight: bold;
        }
        .file-upload-btn:hover { background: #eee; }
        
        #fileNameDisplay {
            font-size: 0.85em; color: #333; margin-left: 5px; max-width: 150px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            display: inline-block; vertical-align: middle;
        }
    </style>
</head>
<body>
    <div class="controls-row">
        <div class="group">
            <label for="fileInput" class="file-upload-btn">üìÇ Select File</label>
            <input type="file" id="fileInput" accept=".txt,.html,.xml,.js,.css">
            <span id="fileNameDisplay">No file chosen</span>
        </div>
        <div class="group"><select id="languageSelect"></select><select id="accentSelect"></select></div>
        <div class="group"><label>Speed:</label><input type="number" id="rateInput" min="0.1" max="10" step="0.1" value="1.0" style="width: 50px;"></div>
        <div class="group"><label>Size:</label><select id="fontSizeSelect"><option value="14">14</option><option value="16">16</option><option value="18">18</option><option value="20" selected>20</option><option value="24">24</option><option value="28">28</option></select></div>
        <button id="playButton">Play</button>
        <button id="stopButton" style="display: none;">Stop</button>
    </div>
    <div class="controls-row">
        <div class="group"><label>Voice 1:</label><select id="voiceSelect"></select></div>
        <div class="group" style="background-color: #e0f7fa; padding: 3px; border-radius: 3px;">
            <input type="checkbox" id="dialogueModeCheck"><label for="dialogueModeCheck">Dialogue Mode</label>
        </div>
        <div class="group"><label>Voice 2:</label><select id="repeatVoiceSelect" disabled></select></div>
    </div>
    <div class="controls-row">
        <div class="group"><label>Loop Text:</label><input type="number" id="loopCount" min="1" value="1" style="width: 40px;"></div>
        <div class="group" style="background-color: #fff3e0; padding: 3px; border-radius: 3px;">
            <input type="checkbox" id="repeatUtteranceCheck"><label for="repeatUtteranceCheck">Repeat Lines</label>
        </div>
        <div class="group"><label>Count:</label><input type="number" id="utteranceRepeatCount" min="1" value="1" disabled style="width: 40px;"></div>
        <div class="group"><label>Wait (ms):</label><input type="number" id="repeatInterval" min="0" value="500" disabled style="width: 60px;"></div>
        <div class="group"><span id="statusDisplay" style="color: blue;"></span></div>
    </div>

    <div id="text" contenteditable="true">–í–≤–µ–¥—ñ—Ç—å —Ç–µ–∫—Å—Ç –∞–±–æ –≤–∏–¥—ñ–ª—ñ—Ç—å —à–º–∞—Ç–æ–∫.

1. –ö–ª—ñ–∫–Ω—ñ—Ç—å –Ω–∞ —Ä—è–¥–æ–∫ -> –≤—ñ–Ω –≤–∏–¥—ñ–ª–∏—Ç—å—Å—è –∂–æ–≤—Ç–∏–º.
2. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å Play -> –ø–æ—á–Ω–µ —á–∏—Ç–∞—Ç–∏ —Å–∞–º–µ –∑ –∂–æ–≤—Ç–æ–≥–æ —Ä—è–¥–∫–∞.
3. –Ø–∫—â–æ –≥—Ä–∞—î -> –∫–ª—ñ–∫ –ø–µ—Ä–µ–Ω–µ—Å–µ —á–∏—Ç–∞–Ω–Ω—è –Ω–∞ –Ω–æ–≤–µ –º—ñ—Å—Ü–µ.
</div>

    <script>
        // --- Elements ---
        const textElement = document.getElementById('text');
        const playButton = document.getElementById('playButton');
        const stopButton = document.getElementById('stopButton');
        const voiceSelect = document.getElementById('voiceSelect');
        const repeatVoiceSelect = document.getElementById('repeatVoiceSelect');
        const languageSelect = document.getElementById('languageSelect');
        const accentSelect = document.getElementById('accentSelect');
        const dialogueModeCheck = document.getElementById('dialogueModeCheck');
        const repeatUtteranceCheck = document.getElementById('repeatUtteranceCheck');
        const utteranceRepeatCountInput = document.getElementById('utteranceRepeatCount');
        const repeatIntervalInput = document.getElementById('repeatInterval');
        const loopCountInput = document.getElementById('loopCount');
        const statusDisplay = document.getElementById('statusDisplay');
        const rateInput = document.getElementById('rateInput');
        const fontSizeSelect = document.getElementById('fontSizeSelect');
        const fileInput = document.getElementById('fileInput');
        const fileNameDisplay = document.getElementById('fileNameDisplay');

        // --- Globals ---
        let speechSynthesis = window.speechSynthesis;
        let voices = [];
        let isReadingActive = false; 
        
        // Core State
        let originalText = ""; 
        let unitMap = []; 
        let currentUnitIndex = 0;
        
        let currentUnitRepeatCount = 0;
        let fullLoopCount = 1;

        // --- Text Processing (Robust Mapping) ---
        
        function cleanTextForSpeech(text) { 
            return text.replace(/\([^)]*\)/g, '').trim(); 
        }
        
        function generateUnitMap() {
            // Force synchronization with DOM
            originalText = textElement.innerText; // innerText –∫—Ä–∞—â–µ –∑–±–µ—Ä—ñ–≥–∞—î –≤—ñ–∑—É–∞–ª—å–Ω—ñ –ø–µ—Ä–µ–Ω–æ—Å–∏ –Ω—ñ–∂ textContent
            // –ê–ª–µ –¥–ª—è exact matching –∫—Ä–∞—â–µ textContent, —è–∫—â–æ –º–∏ –æ–±–µ—Ä–µ–∂–Ω—ñ.
            // –î–ª—è pre-wrap textContent - —Ü–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç.
            originalText = textElement.textContent; 
            
            unitMap = [];
            
            const isLineMode = repeatUtteranceCheck.checked || dialogueModeCheck.checked;
            
            if (isLineMode) {
                // Line Mode: Scan for newlines manually to get exact offsets
                // We iterate chars to find \n
                let start = 0;
                for (let i = 0; i < originalText.length; i++) {
                    if (originalText[i] === '\n') {
                        const line = originalText.substring(start, i);
                        if (line.trim().length > 0) {
                            unitMap.push({ text: line, start: start, end: i }); // end is EXCLUSIVE of \n
                        }
                        start = i + 1;
                    }
                }
                // Last line
                if (start < originalText.length) {
                    const line = originalText.substring(start);
                    if (line.trim().length > 0) {
                        unitMap.push({ text: line, start: start, end: originalText.length });
                    }
                }
            } else {
                // Sentence Mode
                const regex = /[^.!?]+[.!?]*/g;
                let match;
                while ((match = regex.exec(originalText)) !== null) {
                    if (match[0].trim().length > 0) {
                        unitMap.push({
                            text: match[0],
                            start: match.index,
                            end: match.index + match[0].length
                        });
                    }
                }
            }
        }

        // --- Visuals (No Ghost Line Fix) ---
        
        function highlightUnit(index) {
            if (unitMap.length === 0) generateUnitMap();
            if (!unitMap[index]) return;
            
            const unit = unitMap[index];
            const fullText = originalText; 
            
            // Highlight strictly the text range, EXCLUDING the newline char at `end`
            // unit.end in LineMode logic above points exactly TO the \n (exclusive for substring)
            // So we don't wrap the \n in the span.
            
            const before = fullText.substring(0, unit.start);
            const marked = fullText.substring(unit.start, unit.end);
            const after = fullText.substring(unit.end);
            
            textElement.innerHTML = `${before}<span class="highlight">${marked}</span>${after}`;
        }

        function removeHighlight() {
            // Restore pure text safely
            if (textElement.innerHTML.includes('span')) {
                textElement.textContent = originalText;
            }
        }

        // --- Cursor Logic ---
        
        function calculateIndexFromCursor() {
            const sel = window.getSelection();
            if (!sel.rangeCount || !textElement.contains(sel.anchorNode)) return currentUnitIndex;

            const range = sel.getRangeAt(0);
            const preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(textElement);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            
            const caretOffset = preCaretRange.toString().length;
            
            // Refresh map
            generateUnitMap();
            
            if (unitMap.length === 0) return 0;

            for (let i = 0; i < unitMap.length; i++) {
                // Check bounds. Allow +1 tolerance for end of line cursor.
                // But strictly check next unit start to avoid overlap.
                if (caretOffset >= unitMap[i].start && caretOffset <= unitMap[i].end + 1) {
                    return i;
                }
                // Gap check (empty lines)
                if (i < unitMap.length - 1 && caretOffset > unitMap[i].end && caretOffset < unitMap[i+1].start) {
                    return i + 1;
                }
            }
            return unitMap.length - 1;
        }

        // --- Helper ---
        function getHumanReadableAccent(accentTag) {
            const parts = accentTag.replace('_', '-').split('-');
            const language = parts[0].toUpperCase();
            const region = parts.length > 1 ? parts[1].toUpperCase() : '';
            const map = { 'US':'USA', 'GB':'UK', 'UA':'–£–∫—Ä–∞—ó–Ω–∞', 'RU':'–†–æ—Å—ñ—è', 'CN':'China' };
            let name = language === 'UK' ? 'Ukr' : (language === 'EN' ? 'Eng' : language);
            if(region) return `${name} (${map[region]||region})`;
            return name;
        }

        // --- File Handling ---
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            fileNameDisplay.textContent = file.name;
            const reader = new FileReader();
            reader.onload = function(e) {
                stopReading();
                textElement.textContent = e.target.result;
                originalText = e.target.result;
                fileInput.value = ''; 
                currentUnitIndex = 0;
                generateUnitMap();
            };
            reader.readAsText(file); 
        }

        // --- Playback Logic ---

        function stopReading() {
            isReadingActive = false;
            speechSynthesis.cancel();
            removeHighlight();
            playButton.style.display = 'inline';
            stopButton.style.display = 'none';
            statusDisplay.textContent = '';
        }

        function StartReading() {
            speechSynthesis.cancel();
            isReadingActive = true;
            playButton.style.display = 'none';
            stopButton.style.display = 'inline';
            
            generateUnitMap();
            
            if (unitMap.length === 0) { stopReading(); return; }

            if (currentUnitIndex >= unitMap.length) currentUnitIndex = 0;

            currentUnitRepeatCount = 0;
            fullLoopCount = parseInt(loopCountInput.value) || 1;
            updateStatus(repeatUtteranceCheck.checked, parseInt(utteranceRepeatCountInput.value) || 1);
            
            speakNext();
        }

        function speakNext() {
            if (!isReadingActive) return;

            const maxRepeats = parseInt(utteranceRepeatCountInput.value) || 1;
            const waitTime = parseInt(repeatIntervalInput.value) || 500;
            const doRepeat = repeatUtteranceCheck.checked;
            const isDialogue = dialogueModeCheck.checked;
            const rate = parseFloat(rateInput.value) || 1.0;

            if (currentUnitIndex >= unitMap.length) {
                fullLoopCount--;
                if (fullLoopCount > 0) {
                    currentUnitIndex = 0;
                    setTimeout(speakNext, doRepeat ? waitTime : 0);
                } else {
                    stopReading();
                }
                return;
            }

            let voiceName = voiceSelect.value;
            if (isDialogue && currentUnitIndex % 2 !== 0) {
                voiceName = repeatVoiceSelect.value;
            }
            const activeVoice = voices.find(v => v.name === voiceName);
            if (!activeVoice) { alert("Select a voice!"); stopReading(); return; }

            const unitObj = unitMap[currentUnitIndex];
            const textToSpeak = cleanTextForSpeech(unitObj.text);
            
            const utter = new SpeechSynthesisUtterance(textToSpeak);
            utter.voice = activeVoice;
            utter.rate = rate;

            utter.onstart = () => {
                if (!isReadingActive) { speechSynthesis.cancel(); return; }
                
                if (doRepeat) {
                    currentUnitRepeatCount++;
                    updateStatus(true, maxRepeats);
                    if (currentUnitRepeatCount === 1) highlightUnit(currentUnitIndex);
                } else {
                    highlightUnit(currentUnitIndex);
                }
            };

            utter.onend = () => {
                if (!isReadingActive) return;
                if (doRepeat && currentUnitRepeatCount < maxRepeats) {
                    setTimeout(speakNext, waitTime);
                } else {
                    currentUnitRepeatCount = 0;
                    currentUnitIndex++;
                    setTimeout(speakNext, doRepeat ? waitTime : 0);
                }
            };

            utter.onerror = (e) => { console.error(e); stopReading(); };
            speechSynthesis.speak(utter);
        }

        function updateStatus(isRepeat, max) {
            if (isRepeat) statusDisplay.textContent = `Rep: ${currentUnitRepeatCount}/${max}`;
            else statusDisplay.textContent = "";
        }

        // --- Listeners ---

        window.addEventListener('load', loadVoices);
        window.speechSynthesis.onvoiceschanged = () => loadVoices();

        function loadVoices() {
            if (!window.speechSynthesis) return;
            voices = speechSynthesis.getVoices();
            if (voices.length === 0) { setTimeout(loadVoices, 500); return; }
            const langs = [...new Set(voices.map(v => v.lang.replace('_', '-').split('-')[0]))];
            languageSelect.innerHTML = '';
            langs.forEach(l => { const o = document.createElement('option'); o.value = l; o.innerText = l.toUpperCase(); languageSelect.appendChild(o); });
            const savedLang = localStorage.getItem('selLang') || 'uk';
            if (langs.includes(savedLang)) languageSelect.value = savedLang; else if (langs.includes('en')) languageSelect.value = 'en';
            updateAccents();
        }
        function updateAccents() {
            const lang = languageSelect.value;
            localStorage.setItem('selLang', lang);
            accentSelect.innerHTML = '';
            const fil = voices.filter(v => v.lang.replace('_', '-').startsWith(lang));
            const accs = [...new Set(fil.map(v => v.lang))];
            accs.forEach(a => { const o = document.createElement('option'); o.value = a; o.innerText = getHumanReadableAccent(a); accentSelect.appendChild(o); });
            const savedAcc = localStorage.getItem('selAcc');
            if (accs.includes(savedAcc)) accentSelect.value = savedAcc; else if (accs.length > 0) accentSelect.value = accs[0];
            updateVoices();
        }
        function updateVoices() {
            const acc = accentSelect.value;
            localStorage.setItem('selAcc', acc);
            const fil = voices.filter(v => v.lang === acc);
            voiceSelect.innerHTML = ''; repeatVoiceSelect.innerHTML = '';
            if(fil.length===0) { const o = document.createElement('option'); o.text="No voices"; voiceSelect.add(o); repeatVoiceSelect.add(o.cloneNode(true)); return; }
            fil.forEach(v => {
                const o = document.createElement('option'); o.value = v.name;
                let name = v.name.replace(/(Google|Microsoft)\s*/g, '').replace(/\s*\(.*?\)/g, '').trim();
                o.innerText = name;
                if(v.default) o.innerText += ' (default)';
                voiceSelect.appendChild(o.cloneNode(true));
                repeatVoiceSelect.appendChild(o);
            });
            const v1 = localStorage.getItem('v1'); const v2 = localStorage.getItem('v2');
            if (v1 && fil.some(v => v.name === v1)) voiceSelect.value = v1;
            if (v2 && fil.some(v => v.name === v2)) repeatVoiceSelect.value = v2;
            if (!voiceSelect.value && fil.length > 0) voiceSelect.value = fil[0].name;
            if (!repeatVoiceSelect.value && fil.length > 0) repeatVoiceSelect.value = fil[1]?.name || fil[0].name;
        }

        languageSelect.addEventListener('change', updateAccents);
        accentSelect.addEventListener('change', updateVoices);
        voiceSelect.addEventListener('change', function(){ localStorage.setItem('v1', this.value) });
        repeatVoiceSelect.addEventListener('change', function(){ localStorage.setItem('v2', this.value) });
        fontSizeSelect.addEventListener('change', function() { textElement.style.fontSize = this.value + 'px'; });
        dialogueModeCheck.addEventListener('change', function() { repeatVoiceSelect.disabled = !this.checked; });
        repeatUtteranceCheck.addEventListener('change', function() {
            utteranceRepeatCountInput.disabled = !this.checked;
            repeatIntervalInput.disabled = !this.checked;
        });

        playButton.addEventListener('click', () => StartReading()); 
        stopButton.addEventListener('click', stopReading);
        fileInput.addEventListener('change', handleFileSelect);
        
        // --- CLICK HANDLER ---
        textElement.addEventListener('click', (e) => {
            const sel = window.getSelection();
            if (sel.type === 'Range' && !sel.isCollapsed) return;

            setTimeout(() => {
                const newIndex = calculateIndexFromCursor();
                // Update Truth
                currentUnitIndex = newIndex;

                if (isReadingActive) {
                    StartReading(); // JUMP
                } else {
                    highlightUnit(newIndex); // PREVIEW
                }
            }, 10);
        });
        
        textElement.addEventListener('dblclick', () => {
            const sel = window.getSelection();
            if (sel.rangeCount > 0) sel.collapseToStart();
            
            setTimeout(() => {
                currentUnitIndex = calculateIndexFromCursor();
                StartReading();
            }, 20);
        });

    </script>
</body>
</html>
