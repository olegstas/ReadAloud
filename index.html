<!DOCTYPE html>
<html>
<head>
    <title>Text Reader</title>
    <style>
        .highlight {
            background-color: yellow;
        }

        select {
            max-width: 200px;
        }

        #text {
            width: 100%;
            height: calc(100vh - 200px);
            border: 1px solid #ccc;
            padding: 10px;
            box-sizing: border-box;
            overflow: auto;
            white-space: pre-wrap;
            font-family: monospace;
            line-height: 1.5;
            margin-top: 10px;
        }

        body {
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            font-family: sans-serif;
        }

        .controls-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            margin-bottom: 10px;
            background: #f9f9f9;
            padding: 5px;
            border-radius: 5px;
        }

        .group {
            display: flex;
            align-items: center;
            gap: 5px;
            border-right: 1px solid #ddd;
            padding-right: 10px;
        }
        .group:last-child {
            border-right: none;
        }

        label {
            font-size: 0.9em;
            font-weight: bold;
        }
        
        button {
            padding: 5px 15px;
            cursor: pointer;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="controls-row">
        <div class="group">
            <input type="file" id="fileInput" accept=".txt,.html,.xml,.js,.css">
        </div>
        <div class="group">
            <select id="languageSelect"></select>
            <select id="accentSelect"></select>
        </div>
        <div class="group">
            <label for="rateInput">Speed:</label>
            <input type="number" id="rateInput" min="0.1" max="10" step="0.1" value="1.0" style="width: 50px;">
        </div>
        <div class="group">
            <label for="fontSizeSelect">Size:</label>
            <select id="fontSizeSelect">
                <option value="14">14</option>
                <option value="16">16</option>
                <option value="18">18</option>
                <option value="20" selected>20</option>
                <option value="24">24</option>
            </select>
        </div>
        <button id="playButton">Play</button>
        <button id="stopButton" style="display: none;">Stop</button>
    </div>

    <div class="controls-row">
        <div class="group">
            <label for="voiceSelect">Voice 1:</label>
            <select id="voiceSelect"></select>
        </div>
        
        <div class="group" style="background-color: #e0f7fa; padding: 3px; border-radius: 3px;">
            <input type="checkbox" id="dialogueModeCheck">
            <label for="dialogueModeCheck">Dialogue Mode (Use Voice 2)</label>
        </div>

        <div class="group">
            <label for="repeatVoiceSelect">Voice 2:</label>
            <select id="repeatVoiceSelect" disabled></select>
        </div>
    </div>

    <div class="controls-row">
        <div class="group">
            <label for="loopCount">Text Loop:</label>
            <input type="number" id="loopCount" min="1" value="1" style="width: 40px;">
        </div>

        <div class="group" style="background-color: #fff3e0; padding: 3px; border-radius: 3px;">
            <input type="checkbox" id="repeatUtteranceCheck">
            <label for="repeatUtteranceCheck">Repeat Lines</label>
        </div>

        <div class="group">
            <label for="utteranceRepeatCount">Count:</label>
            <input type="number" id="utteranceRepeatCount" min="1" value="1" disabled style="width: 40px;">
        </div>
        <div class="group">
            <label for="repeatInterval">Wait (ms):</label>
            <input type="number" id="repeatInterval" min="0" value="500" disabled style="width: 60px;">
        </div>
        <div class="group">
            <span id="statusDisplay" style="color: blue; font-weight: normal;"></span>
        </div>
    </div>

    <div id="text" contenteditable="true">Введіть текст або завантажте файл.

Приклад (поставте курсор сюди і натисніть Play):
— Привіт! (Голос 1)
— Як справи? (Голос 2, якщо увімкнено Dialogue Mode)
— Все добре. (Голос 1)

Якщо додатково увімкнути "Repeat Lines", кожна строчка буде прочитана кілька разів.
</div>

    <script>
        // --- DOM Elements ---
        const languageSelect = document.getElementById('languageSelect');
        const accentSelect = document.getElementById('accentSelect');
        const voiceSelect = document.getElementById('voiceSelect'); 
        const repeatVoiceSelect = document.getElementById('repeatVoiceSelect'); 
        const fontSizeSelect = document.getElementById('fontSizeSelect');
        const rateInput = document.getElementById('rateInput');
        const playButton = document.getElementById('playButton');
        const stopButton = document.getElementById('stopButton');
        const loopCountInput = document.getElementById('loopCount');
        const textElement = document.getElementById('text');
        
        // Checkboxes
        const dialogueModeCheck = document.getElementById('dialogueModeCheck'); 
        const repeatUtteranceCheck = document.getElementById('repeatUtteranceCheck');
        
        // Inputs
        const utteranceRepeatCountInput = document.getElementById('utteranceRepeatCount');
        const statusDisplay = document.getElementById('statusDisplay');
        const repeatIntervalInput = document.getElementById('repeatInterval');
        const fileInput = document.getElementById('fileInput'); 

        // --- State Variables ---
        let speechSynthesis = window.speechSynthesis;
        let voices = [];
        let isCancelled = false;
        let originalText = '';
        let speechUnits = [];      
        let currentUnitIndex = 0;
        let currentUnitRepeatCount = 0;
        let fullLoopCount = 1;
        let isSelectionMode = false;

        // --- Utility Functions ---

        function cleanText(text) {
            return text.replace(/\([^)]*\)/g, '').trim();
        }

        function splitIntoSentences(text) {
            return text.split(/(?<=[.!?])\s+/).filter(s => s.trim().length > 0);
        }
        
        function splitIntoLinesByNewline(text) {
            const normalizedText = text.replace(/\r/g, ''); 
            return normalizedText.split('\n').filter(s => s.trim().length > 0);
        }

        function getHumanReadableAccent(accentTag) {
            const parts = accentTag.split('-');
            const language = parts[0].toUpperCase();
            const region = parts.length > 1 ? parts[1].toUpperCase() : '';
            const regionNames = {
                'US': 'USA', 'GB': 'UK', 'CA': 'Canada', 'AU': 'Australia', 'IN': 'India',
                'IE': 'Ireland', 'FR': 'France', 'DE': 'Germany', 'UA': 'Україна', 
                'RU': 'Росія', 'IT': 'Італія', 'ES': 'Іспанія', 'JP': 'Японія', 'CN': 'Китай'
            };
            let langName = language === 'UK' ? 'Українська' : (language === 'EN' ? 'English' : language);
            if (region) return `${langName} (${regionNames[region] || region})`;
            return langName;
        }

        // --- File Handling ---
        
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                textElement.textContent = e.target.result;
                fileInput.value = ''; 
            };
            reader.readAsText(file); 
        }

        // --- Voice Loading ---

        window.speechSynthesis.onvoiceschanged = () => loadVoices();

        function loadVoices() {
            if (!('speechSynthesis' in window)) return;
            voices = speechSynthesis.getVoices();
            if (voices.length === 0) { setTimeout(loadVoices, 500); return; }

            const baseLanguages = [...new Set(voices.map(voice => voice.lang.split('-')[0]))];
            languageSelect.innerHTML = '';
            baseLanguages.forEach(language => {
                const option = document.createElement('option');
                option.value = language;
                option.innerText = language.toUpperCase();
                languageSelect.appendChild(option);
            });

            const savedLanguage = localStorage.getItem('selectedLanguage') || 'uk'; 
            languageSelect.value = savedLanguage;
            updateAccents(savedLanguage);
        }
        
        function fillVoiceSelects(filteredVoices) {
            voiceSelect.innerHTML = '';
            repeatVoiceSelect.innerHTML = '';

            filteredVoices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.name;
                
                let displayName = voice.name.replace('Google', '').replace('Microsoft', '').trim();
                displayName = displayName.replace(new RegExp(`\\s*\\(${voice.lang}\\)`, 'i'), '').trim();
                
                option.innerText = displayName;
                if (voice.default) option.innerText += ' (default)';
                
                voiceSelect.appendChild(option.cloneNode(true));
                repeatVoiceSelect.appendChild(option);
            });
            
            if (localStorage.getItem('selectedVoice')) voiceSelect.value = localStorage.getItem('selectedVoice');
            if (localStorage.getItem('selectedRepeatVoice')) repeatVoiceSelect.value = localStorage.getItem('selectedRepeatVoice');
            
            if (!voiceSelect.value && filteredVoices.length > 0) voiceSelect.value = filteredVoices[0].name;
            if (!repeatVoiceSelect.value && filteredVoices.length > 0) repeatVoiceSelect.value = filteredVoices[1]?.name || filteredVoices[0].name;
        }

        function updateAccents(baseLanguage) {
            accentSelect.innerHTML = '';
            const filteredVoices = voices.filter(voice => voice.lang.startsWith(baseLanguage));
            const accents = [...new Set(filteredVoices.map(voice => voice.lang))];
            
            accents.forEach(accent => {
                const option = document.createElement('option');
                option.value = accent;
                option.innerText = getHumanReadableAccent(accent);
                accentSelect.appendChild(option);
            });

            const savedAccent = localStorage.getItem('selectedAccent') || accents[0];
            accentSelect.value = savedAccent;
            updateVoicesByAccent(savedAccent);
        }

        function updateVoicesByAccent(fullAccentTag) {
            const filteredVoices = voices.filter(voice => voice.lang === fullAccentTag);
            fillVoiceSelects(filteredVoices); 
        }

        // --- Cursor and Highlighting Logic ---

        function getCurrentSpeechUnitIndex() {
            if (isSelectionMode) return 0;
            
            const sel = window.getSelection();
            if (sel.rangeCount === 0) return 0;

            const range = sel.getRangeAt(0);
            // Get all text before the cursor
            const preCursorRange = range.cloneRange();
            preCursorRange.selectNodeContents(textElement);
            preCursorRange.setEnd(range.startContainer, range.startOffset);
            const preCursorText = preCursorRange.toString();
            
            const cleanedPreCursor = cleanText(preCursorText);
            
            // Count how many speech units fit into the pre-cursor text
            let charCount = 0;
            for (let i = 0; i < speechUnits.length; i++) {
                charCount += speechUnits[i].length;
                // Small tolerance for spaces/newlines that might be missing in cleaned text
                if (charCount >= cleanedPreCursor.length) {
                    return i;
                }
            }
            return 0;
        }

        function highlightSpeechUnit(unitIndex) {
            unhighlightText();
            
            if (isSelectionMode) {
                const sel = window.getSelection();
                if (sel.rangeCount > 0) {
                    const range = sel.getRangeAt(0);
                    const span = document.createElement('span');
                    span.className = 'highlight';
                    try { range.surroundContents(span); } catch (e) {}
                }
                return;
            }
            
            const unitText = speechUnits[unitIndex];
            if (!unitText) return;

            // Find where this specific unit (Nth unit) starts in the original text
            let currentCursor = 0;
            let matchIndex = -1;
            
            const isLineMode = repeatUtteranceCheck.checked || dialogueModeCheck.checked;
            
            // Re-split original text exactly as we did for speechUnits to find the Nth occurrence
            const originalUnits = isLineMode ? 
                originalText.replace(/\r/g, '').split('\n') : 
                originalText.split(/(?<=[.!?])\s+/);
            
            // Iterate through original units to find the start position of the target unitIndex
            for (let i = 0; i < originalUnits.length; i++) {
                const originalUnit = originalUnits[i];
                const len = originalUnit.length;
                
                if (i === unitIndex) {
                    // Found our unit! matchIndex is currentCursor + where it actually starts (ignoring leading whitespace of the block if any)
                    // Note: originalText.indexOf might pick up previous duplicates, so we must track position manually
                    matchIndex = currentCursor;
                    break;
                }
                
                // Advance cursor by length of unit + separator (approximate)
                // To be precise, we just need the cumulative length of previous blocks
                currentCursor += len; 
                
                // Add back the separator length that was stripped by split? 
                // Actually split retains punctuation for sentences, but removes \n for lines.
                if (isLineMode) currentCursor += 1; // Add back newline length
            }

            if (matchIndex !== -1) {
                // Now we need to safely wrap the text at matchIndex
                // Since originalUnits[unitIndex] contains the exact text from originalText (mostly), use its length
                const unitLength = originalUnits[unitIndex].length;
                
                const highlightedText = originalText.slice(0, matchIndex) + 
                    '<span class="highlight">' + originalText.slice(matchIndex, matchIndex + unitLength) + '</span>' + 
                    originalText.slice(matchIndex + unitLength);
                
                textElement.innerHTML = highlightedText;
            }
        }

        function unhighlightText() {
            // This removes the <span> tags but keeps the text
            textElement.innerHTML = textElement.textContent;
        }

        function ReadText() {
            isCancelled = false;
            
            // Always capture text content first to avoid HTML tag interference
            originalText = textElement.textContent;
            
            const selectedText = window.getSelection().toString().trim();
            isSelectionMode = selectedText.length > 0;
            
            const isDialogue = dialogueModeCheck.checked;
            const isRepeat = repeatUtteranceCheck.checked;
            const cleanedText = cleanText(originalText);
            
            if (isSelectionMode) {
                const cleanedSelection = cleanText(selectedText);
                if (cleanedSelection.length === 0) { stopReading(); return; }
                speechUnits = [cleanedSelection];
                currentUnitIndex = 0; // Selection always starts at 0 relative to selection
            } else {
                if (isRepeat || isDialogue) {
                    speechUnits = splitIntoLinesByNewline(cleanedText); 
                } else {
                    speechUnits = splitIntoSentences(cleanedText);
                }
                // Determine start index based on cursor
                currentUnitIndex = getCurrentSpeechUnitIndex();
            }
            
            if (speechUnits.length === 0) { stopReading(); return; }

            currentUnitRepeatCount = 0;
            fullLoopCount = parseInt(loopCountInput.value) || 1;
            const maxUnitRepeats = parseInt(utteranceRepeatCountInput.value) || 1;
            const repeatIntervalMs = parseInt(repeatIntervalInput.value) || 500;
            const rate = parseFloat(rateInput.value) || 1.0;

            updateStatus(isRepeat, maxUnitRepeats);

            const speakNext = (delay = 0) => {
                if (isCancelled) return;

                if (currentUnitIndex >= speechUnits.length) {
                    fullLoopCount--;
                    if (fullLoopCount > 0) {
                        currentUnitIndex = 0;
                        loopCountInput.value = fullLoopCount;
                        speakNext(isRepeat ? repeatIntervalMs : 0);
                    } else {
                        stopReading();
                    }
                    return;
                }

                let selectedVoiceName = voiceSelect.value;
                if (isDialogue && currentUnitIndex % 2 !== 0) {
                    selectedVoiceName = repeatVoiceSelect.value;
                }

                const selectedVoice = voices.find(voice => voice.name === selectedVoiceName);
                const unit = speechUnits[currentUnitIndex];
                const utterance = new SpeechSynthesisUtterance(unit);
                utterance.voice = selectedVoice;
                utterance.rate = rate;

                utterance.onstart = () => {
                    if (isRepeat) {
                        currentUnitRepeatCount++;
                        updateStatus(true, maxUnitRepeats);
                        if (currentUnitRepeatCount === 1) highlightSpeechUnit(currentUnitIndex);
                    } else {
                        highlightSpeechUnit(currentUnitIndex);
                    }
                };

                utterance.onend = () => {
                    if (isRepeat && currentUnitRepeatCount < maxUnitRepeats) {
                        speakNext(repeatIntervalMs);
                    } else {
                        currentUnitIndex++;
                        currentUnitRepeatCount = 0;
                        speakNext(isRepeat ? repeatIntervalMs : 0);
                    }
                };
                
                setTimeout(() => speechSynthesis.speak(utterance), delay);
            };
            
            speakNext();
        }
        
        function updateStatus(isRepeat, max) {
            if (isRepeat) {
                statusDisplay.textContent = `Rep: ${currentUnitRepeatCount} / ${max}`;
            } else {
                statusDisplay.textContent = "";
            }
        }

        function stopReading() {
            speechSynthesis.cancel();
            isCancelled = true;
            unhighlightText();
            playButton.style.display = 'inline';
            stopButton.style.display = 'none';
            statusDisplay.textContent = "";
        }

        // --- Event Listeners ---
        window.addEventListener('load', loadVoices);
        
        languageSelect.addEventListener('change', function () { localStorage.setItem('selectedLanguage', this.value); updateAccents(this.value); });
        accentSelect.addEventListener('change', function () { localStorage.setItem('selectedAccent', this.value); updateVoicesByAccent(this.value); });
        voiceSelect.addEventListener('change', function () { localStorage.setItem('selectedVoice', this.value); });
        repeatVoiceSelect.addEventListener('change', function () { localStorage.setItem('selectedRepeatVoice', this.value); });
        fontSizeSelect.addEventListener('change', function () { textElement.style.fontSize = `${this.value}px`; });
        fileInput.addEventListener('change', handleFileSelect);

        repeatUtteranceCheck.addEventListener('change', function () {
            utteranceRepeatCountInput.disabled = !this.checked;
            repeatIntervalInput.disabled = !this.checked;
        });

        dialogueModeCheck.addEventListener('change', function() {
            repeatVoiceSelect.disabled = !this.checked;
        });

        playButton.addEventListener('click', function () {
            speechSynthesis.cancel(); 
            playButton.style.display = 'none';
            stopButton.style.display = 'inline';
            ReadText();
        });

        stopButton.addEventListener('click', stopReading);
    </script>
</body>
</html>
